//@ts-nocheck
// DO NOT MODIFY THIS FILE. This file is automatically generated by Tina
export function gql(strings: TemplateStringsArray, ...args: string[]): string {
	let str = '';
	strings.forEach((string, i) => {
		str += string + (args[i] || '');
	});
	return str;
}
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
	[K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
	[SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
	[SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<
	T extends { [key: string]: unknown },
	K extends keyof T
> = { [_ in K]?: never };
export type Incremental<T> =
	| T
	| {
			[P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
	  };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
	ID: { input: string; output: string };
	String: { input: string; output: string };
	Boolean: { input: boolean; output: boolean };
	Int: { input: number; output: number };
	Float: { input: number; output: number };
	/** References another document, used as a foreign key */
	Reference: { input: any; output: any };
	JSON: { input: any; output: any };
};

export type SystemInfo = {
	__typename?: 'SystemInfo';
	filename: Scalars['String']['output'];
	title?: Maybe<Scalars['String']['output']>;
	basename: Scalars['String']['output'];
	breadcrumbs: Array<Scalars['String']['output']>;
	path: Scalars['String']['output'];
	relativePath: Scalars['String']['output'];
	extension: Scalars['String']['output'];
	template: Scalars['String']['output'];
	collection: Collection;
};

export type SystemInfoBreadcrumbsArgs = {
	excludeExtension?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Folder = {
	__typename?: 'Folder';
	name: Scalars['String']['output'];
	path: Scalars['String']['output'];
};

export type PageInfo = {
	__typename?: 'PageInfo';
	hasPreviousPage: Scalars['Boolean']['output'];
	hasNextPage: Scalars['Boolean']['output'];
	startCursor: Scalars['String']['output'];
	endCursor: Scalars['String']['output'];
};

export type Node = {
	id: Scalars['ID']['output'];
};

export type Document = {
	id: Scalars['ID']['output'];
	_sys?: Maybe<SystemInfo>;
	_values: Scalars['JSON']['output'];
};

/** A relay-compliant pagination connection */
export type Connection = {
	totalCount: Scalars['Float']['output'];
	pageInfo: PageInfo;
};

export type Query = {
	__typename?: 'Query';
	getOptimizedQuery?: Maybe<Scalars['String']['output']>;
	collection: Collection;
	collections: Array<Collection>;
	node: Node;
	document: DocumentNode;
	projects: Projects;
	projectsConnection: ProjectsConnection;
};

export type QueryGetOptimizedQueryArgs = {
	queryString: Scalars['String']['input'];
};

export type QueryCollectionArgs = {
	collection?: InputMaybe<Scalars['String']['input']>;
};

export type QueryNodeArgs = {
	id?: InputMaybe<Scalars['String']['input']>;
};

export type QueryDocumentArgs = {
	collection?: InputMaybe<Scalars['String']['input']>;
	relativePath?: InputMaybe<Scalars['String']['input']>;
};

export type QueryProjectsArgs = {
	relativePath?: InputMaybe<Scalars['String']['input']>;
};

export type QueryProjectsConnectionArgs = {
	before?: InputMaybe<Scalars['String']['input']>;
	after?: InputMaybe<Scalars['String']['input']>;
	first?: InputMaybe<Scalars['Float']['input']>;
	last?: InputMaybe<Scalars['Float']['input']>;
	sort?: InputMaybe<Scalars['String']['input']>;
	filter?: InputMaybe<ProjectsFilter>;
};

export type DocumentFilter = {
	projects?: InputMaybe<ProjectsFilter>;
};

export type DocumentConnectionEdges = {
	__typename?: 'DocumentConnectionEdges';
	cursor: Scalars['String']['output'];
	node?: Maybe<DocumentNode>;
};

export type DocumentConnection = Connection & {
	__typename?: 'DocumentConnection';
	pageInfo: PageInfo;
	totalCount: Scalars['Float']['output'];
	edges?: Maybe<Array<Maybe<DocumentConnectionEdges>>>;
};

export type Collection = {
	__typename?: 'Collection';
	name: Scalars['String']['output'];
	slug: Scalars['String']['output'];
	label?: Maybe<Scalars['String']['output']>;
	path: Scalars['String']['output'];
	format?: Maybe<Scalars['String']['output']>;
	matches?: Maybe<Scalars['String']['output']>;
	templates?: Maybe<Array<Maybe<Scalars['JSON']['output']>>>;
	fields?: Maybe<Array<Maybe<Scalars['JSON']['output']>>>;
	documents: DocumentConnection;
};

export type CollectionDocumentsArgs = {
	before?: InputMaybe<Scalars['String']['input']>;
	after?: InputMaybe<Scalars['String']['input']>;
	first?: InputMaybe<Scalars['Float']['input']>;
	last?: InputMaybe<Scalars['Float']['input']>;
	sort?: InputMaybe<Scalars['String']['input']>;
	filter?: InputMaybe<DocumentFilter>;
	folder?: InputMaybe<Scalars['String']['input']>;
};

export type DocumentNode = Projects | Folder;

export type ProjectsProjectImages = {
	__typename?: 'ProjectsProjectImages';
	src?: Maybe<Scalars['String']['output']>;
	altText?: Maybe<Scalars['String']['output']>;
};

export type Projects = Node &
	Document & {
		__typename?: 'Projects';
		title: Scalars['String']['output'];
		overview: Scalars['String']['output'];
		tools?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
		summary?: Maybe<Scalars['JSON']['output']>;
		tags?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
		projectImages?: Maybe<Array<Maybe<ProjectsProjectImages>>>;
		id: Scalars['ID']['output'];
		_sys: SystemInfo;
		_values: Scalars['JSON']['output'];
	};

export type StringFilter = {
	startsWith?: InputMaybe<Scalars['String']['input']>;
	eq?: InputMaybe<Scalars['String']['input']>;
	exists?: InputMaybe<Scalars['Boolean']['input']>;
	in?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type RichTextFilter = {
	startsWith?: InputMaybe<Scalars['String']['input']>;
	eq?: InputMaybe<Scalars['String']['input']>;
	exists?: InputMaybe<Scalars['Boolean']['input']>;
};

export type ImageFilter = {
	startsWith?: InputMaybe<Scalars['String']['input']>;
	eq?: InputMaybe<Scalars['String']['input']>;
	exists?: InputMaybe<Scalars['Boolean']['input']>;
	in?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type ProjectsProjectImagesFilter = {
	src?: InputMaybe<ImageFilter>;
	altText?: InputMaybe<StringFilter>;
};

export type ProjectsFilter = {
	title?: InputMaybe<StringFilter>;
	overview?: InputMaybe<StringFilter>;
	tools?: InputMaybe<StringFilter>;
	summary?: InputMaybe<RichTextFilter>;
	tags?: InputMaybe<StringFilter>;
	projectImages?: InputMaybe<ProjectsProjectImagesFilter>;
};

export type ProjectsConnectionEdges = {
	__typename?: 'ProjectsConnectionEdges';
	cursor: Scalars['String']['output'];
	node?: Maybe<Projects>;
};

export type ProjectsConnection = Connection & {
	__typename?: 'ProjectsConnection';
	pageInfo: PageInfo;
	totalCount: Scalars['Float']['output'];
	edges?: Maybe<Array<Maybe<ProjectsConnectionEdges>>>;
};

export type Mutation = {
	__typename?: 'Mutation';
	addPendingDocument: DocumentNode;
	updateDocument: DocumentNode;
	deleteDocument: DocumentNode;
	createDocument: DocumentNode;
	createFolder: DocumentNode;
	updateProjects: Projects;
	createProjects: Projects;
};

export type MutationAddPendingDocumentArgs = {
	collection: Scalars['String']['input'];
	relativePath: Scalars['String']['input'];
	template?: InputMaybe<Scalars['String']['input']>;
};

export type MutationUpdateDocumentArgs = {
	collection?: InputMaybe<Scalars['String']['input']>;
	relativePath: Scalars['String']['input'];
	params: DocumentUpdateMutation;
};

export type MutationDeleteDocumentArgs = {
	collection?: InputMaybe<Scalars['String']['input']>;
	relativePath: Scalars['String']['input'];
};

export type MutationCreateDocumentArgs = {
	collection?: InputMaybe<Scalars['String']['input']>;
	relativePath: Scalars['String']['input'];
	params: DocumentMutation;
};

export type MutationCreateFolderArgs = {
	collection?: InputMaybe<Scalars['String']['input']>;
	relativePath: Scalars['String']['input'];
};

export type MutationUpdateProjectsArgs = {
	relativePath: Scalars['String']['input'];
	params: ProjectsMutation;
};

export type MutationCreateProjectsArgs = {
	relativePath: Scalars['String']['input'];
	params: ProjectsMutation;
};

export type DocumentUpdateMutation = {
	projects?: InputMaybe<ProjectsMutation>;
	relativePath?: InputMaybe<Scalars['String']['input']>;
};

export type DocumentMutation = {
	projects?: InputMaybe<ProjectsMutation>;
};

export type ProjectsProjectImagesMutation = {
	src?: InputMaybe<Scalars['String']['input']>;
	altText?: InputMaybe<Scalars['String']['input']>;
};

export type ProjectsMutation = {
	title?: InputMaybe<Scalars['String']['input']>;
	overview?: InputMaybe<Scalars['String']['input']>;
	tools?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
	summary?: InputMaybe<Scalars['JSON']['input']>;
	tags?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
	projectImages?: InputMaybe<Array<InputMaybe<ProjectsProjectImagesMutation>>>;
};

export type ProjectsPartsFragment = {
	__typename: 'Projects';
	title: string;
	overview: string;
	tools?: Array<string | null> | null;
	summary?: any | null;
	tags?: Array<string | null> | null;
	projectImages?: Array<{
		__typename: 'ProjectsProjectImages';
		src?: string | null;
		altText?: string | null;
	} | null> | null;
};

export type ProjectsQueryVariables = Exact<{
	relativePath: Scalars['String']['input'];
}>;

export type ProjectsQuery = {
	__typename?: 'Query';
	projects: {
		__typename: 'Projects';
		id: string;
		title: string;
		overview: string;
		tools?: Array<string | null> | null;
		summary?: any | null;
		tags?: Array<string | null> | null;
		_sys: {
			__typename?: 'SystemInfo';
			filename: string;
			basename: string;
			breadcrumbs: Array<string>;
			path: string;
			relativePath: string;
			extension: string;
		};
		projectImages?: Array<{
			__typename: 'ProjectsProjectImages';
			src?: string | null;
			altText?: string | null;
		} | null> | null;
	};
};

export type ProjectsConnectionQueryVariables = Exact<{
	before?: InputMaybe<Scalars['String']['input']>;
	after?: InputMaybe<Scalars['String']['input']>;
	first?: InputMaybe<Scalars['Float']['input']>;
	last?: InputMaybe<Scalars['Float']['input']>;
	sort?: InputMaybe<Scalars['String']['input']>;
	filter?: InputMaybe<ProjectsFilter>;
}>;

export type ProjectsConnectionQuery = {
	__typename?: 'Query';
	projectsConnection: {
		__typename?: 'ProjectsConnection';
		totalCount: number;
		pageInfo: {
			__typename?: 'PageInfo';
			hasPreviousPage: boolean;
			hasNextPage: boolean;
			startCursor: string;
			endCursor: string;
		};
		edges?: Array<{
			__typename?: 'ProjectsConnectionEdges';
			cursor: string;
			node?: {
				__typename: 'Projects';
				id: string;
				title: string;
				overview: string;
				tools?: Array<string | null> | null;
				summary?: any | null;
				tags?: Array<string | null> | null;
				_sys: {
					__typename?: 'SystemInfo';
					filename: string;
					basename: string;
					breadcrumbs: Array<string>;
					path: string;
					relativePath: string;
					extension: string;
				};
				projectImages?: Array<{
					__typename: 'ProjectsProjectImages';
					src?: string | null;
					altText?: string | null;
				} | null> | null;
			} | null;
		} | null> | null;
	};
};

export const ProjectsPartsFragmentDoc = gql`
	fragment ProjectsParts on Projects {
		__typename
		title
		overview
		tools
		summary
		tags
		projectImages {
			__typename
			src
			altText
		}
	}
`;
export const ProjectsDocument = gql`
	query projects($relativePath: String!) {
		projects(relativePath: $relativePath) {
			... on Document {
				_sys {
					filename
					basename
					breadcrumbs
					path
					relativePath
					extension
				}
				id
			}
			...ProjectsParts
		}
	}
	${ProjectsPartsFragmentDoc}
`;
export const ProjectsConnectionDocument = gql`
	query projectsConnection(
		$before: String
		$after: String
		$first: Float
		$last: Float
		$sort: String
		$filter: ProjectsFilter
	) {
		projectsConnection(
			before: $before
			after: $after
			first: $first
			last: $last
			sort: $sort
			filter: $filter
		) {
			pageInfo {
				hasPreviousPage
				hasNextPage
				startCursor
				endCursor
			}
			totalCount
			edges {
				cursor
				node {
					... on Document {
						_sys {
							filename
							basename
							breadcrumbs
							path
							relativePath
							extension
						}
						id
					}
					...ProjectsParts
				}
			}
		}
	}
	${ProjectsPartsFragmentDoc}
`;
export type Requester<C = {}> = <R, V>(
	doc: DocumentNode,
	vars?: V,
	options?: C
) => Promise<R>;
export function getSdk<C>(requester: Requester<C>) {
	return {
		projects(
			variables: ProjectsQueryVariables,
			options?: C
		): Promise<{
			data: ProjectsQuery;
			errors?: {
				message: string;
				locations: { line: number; column: number }[];
				path: string[];
			}[];
			variables: ProjectsQueryVariables;
			query: string;
		}> {
			return requester<
				{
					data: ProjectsQuery;
					errors?: {
						message: string;
						locations: { line: number; column: number }[];
						path: string[];
					}[];
					variables: ProjectsQueryVariables;
					query: string;
				},
				ProjectsQueryVariables
			>(ProjectsDocument, variables, options);
		},
		projectsConnection(
			variables?: ProjectsConnectionQueryVariables,
			options?: C
		): Promise<{
			data: ProjectsConnectionQuery;
			errors?: {
				message: string;
				locations: { line: number; column: number }[];
				path: string[];
			}[];
			variables: ProjectsConnectionQueryVariables;
			query: string;
		}> {
			return requester<
				{
					data: ProjectsConnectionQuery;
					errors?: {
						message: string;
						locations: { line: number; column: number }[];
						path: string[];
					}[];
					variables: ProjectsConnectionQueryVariables;
					query: string;
				},
				ProjectsConnectionQueryVariables
			>(ProjectsConnectionDocument, variables, options);
		},
	};
}
export type Sdk = ReturnType<typeof getSdk>;

// TinaSDK generated code
import { createClient, TinaClient } from 'tinacms/dist/client';

const generateRequester = (client: TinaClient) => {
	const requester: (
		doc: any,
		vars?: any,
		options?: {
			branch?: string;
			/**
			 * Aside from `method` and `body`, all fetch options are passed
			 * through to underlying fetch request
			 */
			fetchOptions?: Omit<Parameters<typeof fetch>[1], 'body' | 'method'>;
		},
		client
	) => Promise<any> = async (doc, vars, options) => {
		let url = client.apiUrl;
		if (options?.branch) {
			const index = client.apiUrl.lastIndexOf('/');
			url = client.apiUrl.substring(0, index + 1) + options.branch;
		}
		const data = await client.request(
			{
				query: doc,
				variables: vars,
				url,
			},
			options
		);

		return {
			data: data?.data,
			errors: data?.errors,
			query: doc,
			variables: vars || {},
		};
	};

	return requester;
};

/**
 * @experimental this class can be used but may change in the future
 **/
export const ExperimentalGetTinaClient = () =>
	getSdk(
		generateRequester(
			createClient({
				url: 'http://localhost:4001/graphql',
				queries,
			})
		)
	);

export const queries = (client: TinaClient) => {
	const requester = generateRequester(client);
	return getSdk(requester);
};
